rules_version = '2';
service cloud.firestore {
	match /databases/{database}/documents {

		// ========= Helpers =========
		function isAuthed() {
			return request.auth != null;
		}

		function userDocPath(uid) {
			return /databases/$(database)/documents/users/$(uid);
		}

		// Only call get() if the doc exists to avoid Null value errors
		function hasUserDoc() {
			return isAuthed() && exists(userDocPath(request.auth.uid));
		}

		// Safe accessor for the authed user's orgId
		function authedOrgIdOrEmpty() {
			return hasUserDoc()
				? get(userDocPath(request.auth.uid)).data.orgId
				: "";
		}

		function memberDocPath(orgId, uid) {
			return /databases/$(database)/documents/orgs/$(orgId)/members/$(uid);
		}

		function isMember(orgId) {
			return isAuthed() && exists(memberDocPath(orgId, request.auth.uid));
		}

		function isAdmin(orgId) {
			return isMember(orgId) &&
				get(memberDocPath(orgId, request.auth.uid)).data.role == "admin";
		}

		// ========= Public directory (read-only) =========
		// Use a simple collection with even path segments.
		// Tests should read: /orgDirectory/{orgId}
		match /orgDirectory/{orgId} {
			allow read: if true;     // public listing
			allow write: if false;   // only server/admins write via Admin SDK
		}

		// ========= Organization root documents =========
		// orgs/{orgId}
		match /orgs/{orgId} {
			// Members can read their org doc
			allow get, list: if isMember(orgId);

			// Admins can update their org doc; validate shape on writes
			allow update: if isAdmin(orgId) && (authedOrgIdOrEmpty() == orgId) && validOrgUpdate();

			// Prevent create/delete from client; use Admin SDK or CFs
			allow create, delete: if false;

					function validOrgUpdate() {
						// Example field guards â€” adjust to your schema
						// Never assume fields exist; check with keys().hasAll([...])
						let incoming = request.resource.data;

						// Only allow updates that keep the same orgId (immutable)
						let sameId = (("orgId" in resource.data) && ("orgId" in incoming))
							? (incoming.orgId == resource.data.orgId)
							: true;

						// Accept the existing persisted keys plus a safe writable subset
						let allowedKeys = [
							"orgId", "name", "timezone", "updatedAt", "updatedBy",
							"settings", "ownerUid", "createdAt", "createdBy"
						];
						let allowed = incoming.keys().hasOnly(allowedKeys);

						// Example: if name is provided, it must be non-empty string
						let nameOk = ("name" in incoming) ? (incoming.name is string && incoming.name.size() > 0) : true;

						// Example: if timezone provided, must be string
						let tzOk = ("timezone" in incoming) ? (incoming.timezone is string) : true;

						return sameId && allowed && nameOk && tzOk;
			}
		}

		// ========= Organization membership documents =========
		// orgs/{orgId}/members/{uid}
		match /orgs/{orgId}/members/{uid} {
			// A member can read their own membership doc; admins can read everyone
			allow get: if (isAuthed() && request.auth.uid == uid) || isAdmin(orgId);
			allow list: if isAdmin(orgId); // keep listings restricted

			// Only admins can add or update members, with validation
			allow create, update: if isAdmin(orgId) && validMembership();

			// No client-side deletes
			allow delete: if false;

					function validMembership() {
						let d = request.resource.data;

						// Ensure required fields exist and are well-typed
						let hasReq = d.keys().hasAll(["uid", "orgId", "role", "createdAt"]);
						let uidOk = ("uid" in d) && (d.uid is string) && (d.uid.size() > 0);
						let orgOk = ("orgId" in d) && (d.orgId == orgId);
						let roleOk = ("role" in d) && (d.role is string) && (
							d.role in ["admin", "manager", "member"]
						);

						let allowedKeys = [
							"uid", "orgId", "role", "createdAt", "addedBy",
							"updatedAt", "updatedBy", "joinedAt"
						];
						let allowed = d.keys().hasOnly(allowedKeys);

						return hasReq && uidOk && orgOk && roleOk && allowed;
			}
		}

		// ========= User documents =========
		// users/{uid}
		match /users/{uid} {
			// Owners can read/write their own profile with safe validation
			allow get: if isAuthed() && request.auth.uid == uid;
			allow update: if isAuthed() && request.auth.uid == uid && validUserUpdate();

			// Typically created/managed server-side
			allow create, delete: if false;

			function validUserUpdate() {
				let inc = request.resource.data;

				// Only allow a controlled set of fields to change
				let allowed = inc.keys().hasOnly([
					"displayName", "photoURL", "orgId", "updatedAt", "settings"
				]);

				// If orgId is being set, it must be a string (can be empty string)
				let orgOk = ("orgId" in inc) ? (inc.orgId is string) : true;

				// Never deref org membership here; tests will seed docs before asserting
				return allowed && orgOk;
			}
		}
	}
}
