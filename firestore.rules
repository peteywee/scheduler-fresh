rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    ///////////////////////////////////////////////////////////////////////////
    // Helpers
    ///////////////////////////////////////////////////////////////////////////

    function isSignedIn() {
      return request.auth != null;
    }

    // Path helper for member document
    function memberDocPath(orgId, uid) {
      return /databases/$(database)/documents/orgs/$(orgId)/members/$(uid);
    }

    // Safe membership check using exists() (never access .data without exists())
    function isMember(orgId) {
      return isSignedIn() && exists(memberDocPath(orgId, request.auth.uid));
    }

    // Admin = member whose role is owner|admin (guard with exists())
    function isAdmin(orgId) {
      return isMember(orgId) && (
        get(memberDocPath(orgId, request.auth.uid)).data.role in ['owner', 'admin']
      );
    }

    // auth token orgId claim (tests set this)
    function claimOrgId() {
      return isSignedIn() ? request.auth.token.orgId : null;
    }

    function claimMatches(orgId) {
      return claimOrgId() == orgId;
    }

    // user’s memberDoc(orgId).data.orgId must match claim (test enforces this)
    function memberOrgMatchesClaim(orgId) {
      return isSignedIn() &&
             exists(memberDocPath(orgId, request.auth.uid)) &&
             get(memberDocPath(orgId, request.auth.uid)).data.orgId == claimOrgId();
    }

    ///////////////////////////////////////////////////////////////////////////
    // Organizations (orgs/{orgId})
    // - Read: members/admins
    // - Update: admin AND claim matches path AND userDoc.orgId matches claim
    // - Create/Delete: server-only
    ///////////////////////////////////////////////////////////////////////////
    match /orgs/{orgId} {
      allow read: if isMember(orgId) || isAdmin(orgId);
      allow update: if isAdmin(orgId) && claimMatches(orgId) && memberOrgMatchesClaim(orgId);
      allow create, delete: if false;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Members (orgs/{orgId}/members/{uid})
    // - Read: admin or self
    // - Create/Update: admins only AND claim matches path AND userDoc.orgId matches claim
    // - Delete: server-only
    ///////////////////////////////////////////////////////////////////////////
    match /orgs/{orgId}/members/{uid} {
      allow read: if isAdmin(orgId) || (isSignedIn() && request.auth.uid == uid);
      allow create, update: if isAdmin(orgId) && claimMatches(orgId) && memberOrgMatchesClaim(orgId);
      allow delete: if false;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Parents — org-scoped
    // Default: no client writes. Allow reads for admin and the parent (uid==parentId).
    // Provide explicit subcollections (ledger) and a generic {coll} fallback.
    ///////////////////////////////////////////////////////////////////////////

    // Parent document
    match /orgs/{orgId}/parents/{parentId} {
      allow read: if isAdmin(orgId) || (isSignedIn() && request.auth.uid == parentId);
      allow write: if false;
    }

    // Explicit ledger subcollection (tests may list here)
    match /orgs/{orgId}/parents/{parentId}/ledger/{docId} {
      allow read: if isAdmin(orgId) || (isSignedIn() && request.auth.uid == parentId);
      allow write: if false;
    }

    // Generic fallback for any simple subcollection under parent
    match /orgs/{orgId}/parents/{parentId}/{coll}/{docId} {
      // Reads: admin or the parent (covers list & get)
      allow read: if isAdmin(orgId) || (isSignedIn() && request.auth.uid == parentId);

      // Attendance carve-out lives here using coll discriminator
      allow create: if coll == 'attendance'
                 && isSignedIn()
                 && request.auth.uid == parentId
                 && request.resource.data.keys().hasOnly(['status','date','hours','createdAt','updatedAt'])
                 && request.resource.data.status == 'pending';

      allow update: if coll == 'attendance'
                 && isAdmin(orgId)
                 && request.resource.data.diff(resource.data).changedKeys().hasOnly(['status','updatedAt'])
                 && (request.resource.data.status in ['approved','rejected']);

      allow delete: if false;

      // Any non-attendance writes are blocked by default
      allow write: if false;
    }

    ///////////////////////////////////////////////////////////////////////////
    // Parents — root-scoped fallback (if tests used root paths)
    ///////////////////////////////////////////////////////////////////////////
    match /parents/{parentId} {
      allow read: if isSignedIn() && request.auth.uid == parentId;
      allow write: if false;
    }

    match /parents/{parentId}/ledger/{docId} {
      allow read: if isSignedIn() && (request.auth.uid == parentId || request.auth.token.parentAdmin == true);
      allow write: if false;
    }

    match /parents/{parentId}/{coll}/{docId} {
      allow read: if isSignedIn() && request.auth.uid == parentId;

      allow create: if coll == 'attendance'
                 && isSignedIn()
                 && request.auth.uid == parentId
                 && request.resource.data.keys().hasOnly(['status','date','hours','createdAt','updatedAt'])
                 && request.resource.data.status == 'pending';

      // No global admin context at root; keep client updates closed here.
      allow update, delete: if false;

      // Block non-attendance writes by default
      allow write: if false;
    }
  }
}
